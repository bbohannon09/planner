{"ast":null,"code":"import { useCallback, useMemo, useEffect, useRef } from 'react';\nimport { Capacitor } from '@capacitor/core';\nimport { notAvailable } from './util/models';\nimport { isFeatureAvailable, featureNotAvailableError } from './util/feature-check';\nimport { CapacitorSQLite, SQLiteDBConnection, SQLiteConnection } from '@capacitor-community/sqlite';\nexport { SQLiteDBConnection };\n/**\n * useSQLite Hook\n */\nexport const useSQLite = onProgress => {\n  const platform = Capacitor.getPlatform();\n  const sqlitePlugin = CapacitorSQLite;\n  const mSQLite = useMemo(() => {\n    return new SQLiteConnection(sqlitePlugin);\n  }, [sqlitePlugin]);\n  const listenerHasChangedRef = useRef(false);\n  useEffect(() => {\n    // init Listeners\n    let importListener = null;\n    let exportListener = null;\n    if (platform != \"electron\") {\n      if (onProgress && listenerHasChangedRef.current === false) {\n        console.log(`in onProgress add listeners `);\n        listenerHasChangedRef.current = true;\n        if (onProgress.onProgressImport && sqlitePlugin) importListener = sqlitePlugin.addListener('sqliteImportProgressEvent', e => {\n          if (typeof onProgress.onProgressImport !== 'undefined') onProgress.onProgressImport(e.progress);\n        });\n        if (onProgress.onProgressExport && sqlitePlugin) exportListener = sqlitePlugin.addListener('sqliteExportProgressEvent', e => {\n          if (typeof onProgress.onProgressExport !== 'undefined') onProgress.onProgressExport(e.progress);\n        });\n      }\n    }\n    return () => {\n      if (platform != \"electron\") {\n        console.log(`in return remove listeners `);\n        if (listenerHasChangedRef.current === true) {\n          sqlitePlugin.removeAllListeners();\n        }\n      }\n    };\n  }, []);\n  const availableFeaturesN = {\n    useSQLite: isFeatureAvailable('CapacitorSQLite', 'useSQLite')\n  };\n  /**\n   * Initialize the Web Store\n   */\n  const initWebStore = useCallback(async () => {\n    if (platform != \"web\") {\n      return Promise.reject(`Not implemented on platform ${platform}`);\n    }\n    try {\n      await mSQLite.initWebStore();\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Save the Database to store\n   * @param dbName string\n   */\n  const saveToStore = useCallback(async dbName => {\n    if (platform != \"web\") {\n      return Promise.reject(`Not implemented on platform ${platform}`);\n    }\n    if (dbName.length > 0) {\n      try {\n        await mSQLite.saveToStore(dbName);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database name');\n    }\n  }, [mSQLite]);\n  const echo = useCallback(async value => {\n    if (value) {\n      const r = await mSQLite.echo(value);\n      if (r) {\n        return r;\n      } else {\n        return {\n          value: null\n        };\n      }\n    } else {\n      return {\n        value: null\n      };\n    }\n  }, [mSQLite]);\n  const getPlatform = useCallback(async () => {\n    return {\n      platform: platform\n    };\n  }, [platform]);\n  /**\n   *  Get CapacitorSQLite plugin\n   */\n  const getCapacitorSQLite = async () => {\n    return {\n      plugin: sqlitePlugin\n    };\n  };\n  /**\n   * Create a Connection to Database\n   * @param dbName string\n   * @param encrypted boolean optional\n   * @param mode string optional\n   * @param version number optional\n   * @param readonly boolean optional since 3.0.1\n   */\n  const createConnection = useCallback(async (dbName, encrypted, mode, version, readonly) => {\n    if (dbName == null || dbName.length === 0) {\n      return Promise.reject(new Error('Must provide a database name'));\n    }\n    const mDatabase = dbName;\n    const mVersion = version ? version : 1;\n    const mEncrypted = encrypted ? encrypted : false;\n    const mMode = mode ? mode : \"no-encryption\";\n    const mReadonly = readonly ? readonly : false;\n    try {\n      const r = await mSQLite.createConnection(mDatabase, mEncrypted, mMode, mVersion, mReadonly);\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject(\"No returned connection\");\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Close the Connection to the Database\n   * @param dbName string\n   * @param readonly boolean optional since 3.0.1\n   */\n  const closeConnection = useCallback(async (dbName, readonly) => {\n    const mReadonly = readonly ? readonly : false;\n    if (dbName.length > 0) {\n      try {\n        await mSQLite.closeConnection(dbName, mReadonly);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database name');\n    }\n  }, [mSQLite]);\n  /**\n   * Check if database connection exists\n   * @param database\n   * @param readonly boolean optional since 3.0.1\n   */\n  const isConnection = useCallback(async (dbName, readonly) => {\n    const mReadonly = readonly ? readonly : false;\n    if (dbName.length > 0) {\n      try {\n        const r = await mSQLite.isConnection(dbName, mReadonly);\n        if (r) {\n          return Promise.resolve(r);\n        } else {\n          return Promise.reject(\"No returned isConnection\");\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database name');\n    }\n  }, [mSQLite]);\n  /**\n   * Check if database exists\n   * @param database\n   */\n  const isDatabase = useCallback(async dbName => {\n    if (dbName.length > 0) {\n      try {\n        const r = await mSQLite.isDatabase(dbName);\n        if (r) {\n          return Promise.resolve(r);\n        } else {\n          return Promise.reject(\"Error in isDatabase\");\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database name');\n    }\n  }, [mSQLite]);\n  /**\n   * Check if a SQLite database is encrypted\n   * @param database\n   * @returns Promise<Result>\n   * @since 3.2.0\n   */\n  const isDatabaseEncrypted = useCallback(async dbName => {\n    if (dbName.length > 0) {\n      try {\n        const r = await mSQLite.isDatabaseEncrypted(dbName);\n        if (r) {\n          return Promise.resolve(r);\n        } else {\n          return Promise.reject(\"Error in isDatabaseEncrypted\");\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database name');\n    }\n  }, [mSQLite]);\n  /**\n   * Check encryption value in capacitor.config\n   * @returns Promise<Result>\n   * @since 3.2.0\n   */\n  const isInConfigEncryption = useCallback(async () => {\n    try {\n      const r = await mSQLite.isInConfigEncryption();\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject(\"Error in isInConfigEncryption\");\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Check encryption value in capacitor.config\n   * @returns Promise<Result>\n   * @since 3.2.0\n   */\n  const isInConfigBiometricAuth = useCallback(async () => {\n    try {\n      const r = await mSQLite.isInConfigBiometricAuth();\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject(\"Error in isInConfigBiometricAuth\");\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Get the database list\n   * @returns Promise<capSQLiteValues>\n   * @since 1.0.1 refactor\n   */\n  const getDatabaseList = useCallback(async () => {\n    try {\n      const r = await mSQLite.getDatabaseList();\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject(\"Error in getDatabaseList\");\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Get the migratable database list\n   * @param folderPath\n   *\n   */\n  const getMigratableDbList = useCallback(async folderPath => {\n    const path = folderPath ? folderPath : \"default\";\n    try {\n      const r = await mSQLite.getMigratableDbList(path);\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject(\"Error in getMigratableDbList\");\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Add SQLIte Suffix to existing databases\n   * @param folderPath\n   * @param dbNameList\n   */\n  const addSQLiteSuffix = useCallback(async (folderPath, dbNameList) => {\n    const path = folderPath ? folderPath : \"default\";\n    const dbList = dbNameList ? dbNameList : [];\n    try {\n      await mSQLite.addSQLiteSuffix(path, dbList);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Delete Old Cordova databases\n   * @param folderPath\n   * @param dbNameList\n   */\n  const deleteOldDatabases = useCallback(async (folderPath, dbNameList) => {\n    const path = folderPath ? folderPath : \"default\";\n    const dbList = dbNameList ? dbNameList : [];\n    try {\n      await mSQLite.deleteOldDatabases(path, dbList);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Retrieve a Connection to the Database\n   * @param dbName string\n   * @param readonly boolean optional since 3.0.1\n   */\n  const retrieveConnection = useCallback(async (dbName, readonly) => {\n    const mReadonly = readonly ? readonly : false;\n    if (dbName.length > 0) {\n      try {\n        const r = await mSQLite.retrieveConnection(dbName, mReadonly);\n        if (r) {\n          return Promise.resolve(r);\n        } else {\n          return Promise.reject(\"No returned connection\");\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database name');\n    }\n  }, [mSQLite]);\n  /**\n   * Retrieve all Connections to Databases\n   *\n   */\n  const retrieveAllConnections = useCallback(async () => {\n    try {\n      const r = await mSQLite.retrieveAllConnections();\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject(\"No returned connection\");\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Close All Connections to Databases\n   * @param dbName string\n   */\n  const closeAllConnections = useCallback(async () => {\n    try {\n      await mSQLite.closeAllConnections();\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Import from Json\n   * @param jsonstring string\n   */\n  const importFromJson = useCallback(async jsonstring => {\n    try {\n      const r = await mSQLite.importFromJson(jsonstring);\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject('Error in importFromJson');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Is Json Valid\n   * @param jsonstring string\n   */\n  const isJsonValid = useCallback(async jsonstring => {\n    try {\n      const r = await mSQLite.isJsonValid(jsonstring);\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject('Error Json Object not valid');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Add the upgrade Statement for database version upgrading\n   * @param dbName string\n   * @param upgrade VersionUpgrade\n   */\n  const addUpgradeStatement = useCallback(async (dbName, upgrade) => {\n    if (upgrade === null) {\n      return Promise.reject(new Error(\"Must provide an upgrade statement\"));\n    }\n    if (upgrade.toVersion === null || upgrade.statements === null) {\n      let msg = \"Must provide an upgrade statement with \";\n      msg += \"toVersion & statements\";\n      return Promise.reject(msg);\n    }\n    if (dbName.length > 0) {\n      try {\n        await mSQLite.addUpgradeStatement(dbName, upgrade.toVersion, upgrade.statements);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database name');\n    }\n  }, [mSQLite]);\n  /**\n   * Copy databases from assets to application database folder\n   */\n  const copyFromAssets = useCallback(async overwrite => {\n    const mOverwrite = overwrite != null ? overwrite : true;\n    try {\n      await mSQLite.copyFromAssets(overwrite);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Get databases from HTTP request to application database folder\n   */\n  const getFromHTTPRequest = useCallback(async (url, overwrite) => {\n    const mOverwrite = overwrite != null ? overwrite : true;\n    try {\n      await mSQLite.getFromHTTPRequest(url, overwrite);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Check the consistency between Js Connections\n   * and Native Connections\n   * if inconsistency all connections are removed\n   */\n  const checkConnectionsConsistency = useCallback(async () => {\n    try {\n      const r = await mSQLite.checkConnectionsConsistency();\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject('Error Json Object not valid');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Check if secure secret has been stored\n   * @returns Promise<Result>\n   * @since 2.0.2\n   */\n  const isSecretStored = useCallback(async () => {\n    try {\n      const r = await mSQLite.isSecretStored();\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject('Error in isSecretStored');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Set an encrypted secret to secure storage\n   * To run only once\n   * Will migrate from GlobalSQLite secret when required\n   * @param passphrase\n   * @returns Promise<void>\n   * @since 2.0.2\n  */\n  const setEncryptionSecret = useCallback(async passphrase => {\n    if (passphrase == null || passphrase.length === 0) {\n      return Promise.reject(new Error('Must provide a passphrase'));\n    }\n    try {\n      await mSQLite.setEncryptionSecret(passphrase);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Change encrypted secret from secure storage\n   * Not to use to migrate from GlobalSQLite secret (run setEncryptionSecret)\n   * @param passphrase\n   * @param oldpassphrase\n   * @returns Promise<void>\n   * @since 2.0.2\n   */\n  const changeEncryptionSecret = useCallback(async (passphrase, oldpassphrase) => {\n    if (passphrase == null || passphrase.length === 0) {\n      return Promise.reject(new Error('Must provide a passphrase'));\n    }\n    if (oldpassphrase == null || oldpassphrase.length === 0) {\n      return Promise.reject(new Error('Must provide the old passphrase'));\n    }\n    try {\n      await mSQLite.changeEncryptionSecret(passphrase, oldpassphrase);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Clear the encrypted secret from secure storage\n   * @returns Promise<void>\n   * @since 3.0.0\n   */\n  const clearEncryptionSecret = useCallback(async () => {\n    try {\n      await mSQLite.clearEncryptionSecret();\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Check Encryption Secret\n   *\n   * @param passphrase\n   * @returns Promise<Result>\n   * @since 3.2.0\n   */\n  const checkEncryptionSecret = useCallback(async passphrase => {\n    try {\n      const r = await mSQLite.checkEncryptionSecret(passphrase);\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject('Error in checkEncryptionSecret');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Get a Non-Conformed database path\n   * @param databasePath\n   * @param version\n   * @returns Promise<capNCDatabasePathResult>\n   * @since 2.1.4\n   */\n  const getNCDatabasePath = useCallback(async (folderPath, database) => {\n    if (folderPath == null || folderPath.length === 0) {\n      return Promise.reject(new Error('Must provide a folder path'));\n    }\n    if (database == null || database.length === 0) {\n      return Promise.reject(new Error('Must provide a database name'));\n    }\n    const mFolderPath = folderPath;\n    const mDatabase = database;\n    try {\n      const r = await mSQLite.getNCDatabasePath(mFolderPath, mDatabase);\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject(\"No returned database path\");\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n  * Create a Non-Conformed Database Connection\n  * @param databasePath string\n  * @param version number optional\n  * @since 2.1.4\n  */\n  const createNCConnection = useCallback(async (databasePath, version) => {\n    if (databasePath == null || databasePath.length === 0) {\n      return Promise.reject(new Error('Must provide a database path'));\n    }\n    const mDatabasePath = databasePath;\n    const mVersion = version ? version : 1;\n    try {\n      const r = await mSQLite.createNCConnection(mDatabasePath, mVersion);\n      if (r) {\n        return Promise.resolve(r);\n      } else {\n        return Promise.reject(\"No returned NC connection\");\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  /**\n   * Retrieve a Non-Conformed Database Connection\n   * @param databasePath string\n   * @since 2.1.4\n   */\n  const retrieveNCConnection = useCallback(async databasePath => {\n    if (databasePath.length > 0) {\n      try {\n        const r = await mSQLite.retrieveNCConnection(databasePath);\n        if (r) {\n          return Promise.resolve(r);\n        } else {\n          return Promise.reject(\"No returned NC connection\");\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database path');\n    }\n  }, [mSQLite]);\n  /**\n   * Close a Non-Conformed Database Connection\n   * @param databasePath string\n   * @since 2.1.4\n   */\n  const closeNCConnection = useCallback(async databasePath => {\n    if (databasePath.length > 0) {\n      try {\n        await mSQLite.closeNCConnection(databasePath);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database path');\n    }\n  }, [mSQLite]);\n  /**\n   * Check if a Non-Conformed Database Connection  exists\n   * @param databasePath\n   * @since 2.1.4\n   */\n  const isNCConnection = useCallback(async databasePath => {\n    if (databasePath.length > 0) {\n      try {\n        const r = await mSQLite.isNCConnection(databasePath);\n        if (r) {\n          return Promise.resolve(r);\n        } else {\n          return Promise.reject(\"No returned  NC Connection\");\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database path');\n    }\n  }, [mSQLite]);\n  /**\n   * Check if database exists\n   * @param databasePath\n   * @since 2.1.4\n   */\n  const isNCDatabase = useCallback(async databasePath => {\n    if (databasePath.length > 0) {\n      try {\n        const r = await mSQLite.isNCDatabase(databasePath);\n        if (r) {\n          return Promise.resolve(r);\n        } else {\n          return Promise.reject(\"No returned  NC Connection\");\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    } else {\n      return Promise.reject('Must provide a database path');\n    }\n  }, [mSQLite]);\n  /**\n   * Moves databases to the location the plugin can read them, and adds sqlite suffix\n   * This resembles calling addSQLiteSuffix and deleteOldDatabases, but it is more performant as it doesn't copy but moves the files\n   * @param folderPath the origin from where to move the databases\n   * @param dbNameList the names of the databases to move, check out the getMigratableDbList to get a list, an empty list will result in copying all the databases with '.db' extension.\n   */\n  const moveDatabasesAndAddSuffix = useCallback(async (folderPath, dbNameList) => {\n    const path = folderPath ? folderPath : 'default';\n    const dbList = dbNameList ? dbNameList : [];\n    try {\n      await mSQLite.moveDatabasesAndAddSuffix(path, dbList);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }, [mSQLite]);\n  if (!availableFeaturesN.useSQLite) {\n    return Object.assign({\n      initWebStore: featureNotAvailableError,\n      saveToStore: featureNotAvailableError,\n      echo: featureNotAvailableError,\n      getPlatform: featureNotAvailableError,\n      getCapacitorSQLite: featureNotAvailableError,\n      createConnection: featureNotAvailableError,\n      closeConnection: featureNotAvailableError,\n      retrieveConnection: featureNotAvailableError,\n      retrieveAllConnections: featureNotAvailableError,\n      closeAllConnections: featureNotAvailableError,\n      addUpgradeStatement: featureNotAvailableError,\n      importFromJson: featureNotAvailableError,\n      isJsonValid: featureNotAvailableError,\n      copyFromAssets: featureNotAvailableError,\n      getFromHTTPRequest: featureNotAvailableError,\n      isConnection: featureNotAvailableError,\n      isDatabase: featureNotAvailableError,\n      getNCDatabasePath: featureNotAvailableError,\n      createNCConnection: featureNotAvailableError,\n      closeNCConnection: featureNotAvailableError,\n      retrieveNCConnection: featureNotAvailableError,\n      isNCConnection: featureNotAvailableError,\n      isNCDatabase: featureNotAvailableError,\n      getDatabaseList: featureNotAvailableError,\n      getMigratableDbList: featureNotAvailableError,\n      addSQLiteSuffix: featureNotAvailableError,\n      deleteOldDatabases: featureNotAvailableError,\n      checkConnectionsConsistency: featureNotAvailableError,\n      isSecretStored: featureNotAvailableError,\n      setEncryptionSecret: featureNotAvailableError,\n      changeEncryptionSecret: featureNotAvailableError,\n      clearEncryptionSecret: featureNotAvailableError,\n      checkEncryptionSecret: featureNotAvailableError,\n      moveDatabasesAndAddSuffix: featureNotAvailableError,\n      isInConfigEncryption: featureNotAvailableError,\n      isInConfigBiometricAuth: featureNotAvailableError,\n      isDatabaseEncrypted: featureNotAvailableError\n    }, notAvailable);\n  } else {\n    return {\n      echo,\n      getPlatform,\n      getCapacitorSQLite,\n      createConnection,\n      closeConnection,\n      retrieveConnection,\n      retrieveAllConnections,\n      closeAllConnections,\n      addUpgradeStatement,\n      importFromJson,\n      isJsonValid,\n      copyFromAssets,\n      getFromHTTPRequest,\n      isConnection,\n      isDatabase,\n      getDatabaseList,\n      getMigratableDbList,\n      addSQLiteSuffix,\n      deleteOldDatabases,\n      checkConnectionsConsistency,\n      isSecretStored,\n      setEncryptionSecret,\n      changeEncryptionSecret,\n      clearEncryptionSecret,\n      checkEncryptionSecret,\n      moveDatabasesAndAddSuffix,\n      initWebStore,\n      saveToStore,\n      getNCDatabasePath,\n      createNCConnection,\n      closeNCConnection,\n      retrieveNCConnection,\n      isNCConnection,\n      isNCDatabase,\n      isInConfigEncryption,\n      isInConfigBiometricAuth,\n      isDatabaseEncrypted,\n      isAvailable: true\n    };\n  }\n};","map":{"version":3,"names":["useCallback","useMemo","useEffect","useRef","Capacitor","notAvailable","isFeatureAvailable","featureNotAvailableError","CapacitorSQLite","SQLiteDBConnection","SQLiteConnection","useSQLite","onProgress","platform","getPlatform","sqlitePlugin","mSQLite","listenerHasChangedRef","importListener","exportListener","current","console","log","onProgressImport","addListener","e","progress","onProgressExport","removeAllListeners","availableFeaturesN","initWebStore","Promise","reject","resolve","err","saveToStore","dbName","length","echo","value","r","getCapacitorSQLite","plugin","createConnection","encrypted","mode","version","readonly","Error","mDatabase","mVersion","mEncrypted","mMode","mReadonly","closeConnection","isConnection","isDatabase","isDatabaseEncrypted","isInConfigEncryption","isInConfigBiometricAuth","getDatabaseList","getMigratableDbList","folderPath","path","addSQLiteSuffix","dbNameList","dbList","deleteOldDatabases","retrieveConnection","retrieveAllConnections","closeAllConnections","importFromJson","jsonstring","isJsonValid","addUpgradeStatement","upgrade","toVersion","statements","msg","copyFromAssets","overwrite","mOverwrite","getFromHTTPRequest","url","checkConnectionsConsistency","isSecretStored","setEncryptionSecret","passphrase","changeEncryptionSecret","oldpassphrase","clearEncryptionSecret","checkEncryptionSecret","getNCDatabasePath","database","mFolderPath","createNCConnection","databasePath","mDatabasePath","retrieveNCConnection","closeNCConnection","isNCConnection","isNCDatabase","moveDatabasesAndAddSuffix","Object","assign","isAvailable"],"sources":["C:\\Users\\braed\\Documents\\Personal\\Planner\\node_modules\\react-sqlite-hook\\src\\useSQLite.ts"],"sourcesContent":["import { useCallback, useMemo, useEffect, useRef } from 'react';\nimport { Capacitor } from '@capacitor/core';\nimport { AvailableResult, notAvailable } from './util/models';\nimport { isFeatureAvailable, featureNotAvailableError } \n                                    from './util/feature-check';\nimport { CapacitorSQLite, SQLiteDBConnection, SQLiteConnection,\n         capSQLiteChanges, capSQLiteValues, capNCDatabasePathResult } from '@capacitor-community/sqlite';\n\nexport { SQLiteDBConnection }\n\nexport type SQLiteProps = {\n    onProgressImport?: (progress: string) => void;\n    onProgressExport?: (progress: string) => void;\n}\n/**\n * SQLite Hook Interface\n */\nexport interface SQLiteHook extends AvailableResult {\n    /**\n     * Init the web store\n     * @returns Promise<void>\n     * @since 2.1.0\n     */\n    initWebStore(): Promise<void>;\n    /**\n     * Save the datbase to the web store\n     * @param database\n     * @returns Promise<void>\n     * @since 2.1.0\n     */\n    saveToStore(database: string): Promise<void>;\n     /**\n     * Echo a value\n     * @param value\n     * @returns Promise<{value: string}>\n     * @since 1.0.0 refactor\n     */\n    echo(value: string): Promise<{value: string}>;\n    /**\n     * Get platform\n     * @returns Promise<{platform: string}>\n     * @since 1.0.0 refactor\n     */\n    getPlatform(): Promise<{platform: string}>;\n    /**\n     * Get CapacitorSQLite plugin\n     * @returns Promise<{plugin: any}}>\n     * @since 2.0.3\n     */\n    getCapacitorSQLite(): Promise<{plugin: any}>;\n\n    /**\n     * Add an Upgrade Statement to Update Database Version\n     * @param dbName database name\n     * @param upgrade upgrade statement modified since 3.0.1\n     * @returns Promise<void>\n     * @since 2.0.0\n     */\n    addUpgradeStatement(dbName: string, upgrade: VersionUpgrade)\n                                                    :Promise<void>;\n    /**\n     * Create a connection to a database\n     * @param database\n     * @param encrypted\n     * @param mode\n     * @param version\n     * @param readonly since 3.0.1\n     * @returns Promise<SQLiteDBConnection>\n     * @since 2.0.0 refactor\n     */\n    createConnection(\n        database: string,\n        encrypted?: boolean,\n        mode?: string,\n        version?: number,\n        readonly?: boolean\n    ): Promise<SQLiteDBConnection>;\n    /**\n     * Retrieve an existing database connection\n     * @param database\n     * @param readonly since 3.0.1\n     * @returns Promise<SQLiteDBConnection>\n     * @since 2.0.0\n     */\n    retrieveConnection(database: string, readonly?: boolean): Promise<SQLiteDBConnection>;\n    /**\n     * Retrieve all database connections\n     * @returns Promise<Map<string, SQLiteDBConnection>>\n     * @since 2.0.0\n     */\n    retrieveAllConnections(): Promise<Map<string, SQLiteDBConnection>>;\n    /**\n     * Close a database connection\n     * @param database\n     * @param readonly since 3.0.1\n     * @returns Promise<void>\n     * @since 2.0.0 \n     */\n    closeConnection(database: string, readonly?: boolean): Promise<void>;\n    /**\n     * Close all database connections\n     * @returns Promise<void>\n     * @since 2.0.0\n     */\n    closeAllConnections(): Promise<void>;\n    /**\n     * Check if database connection exists\n     * @param database\n     * @param readonly since 3.0.1\n     * @returns Promise<Result>\n     * @since 2.0.0\n     */\n    isConnection(database: string, readonly?: boolean): Promise<Result>;\n    /**\n     * Check if database exists\n     * @param database\n     * @returns Promise<Result>\n     * @since 2.0.0\n     */\n    isDatabase(database: string): Promise<Result>;\n    /**\n     * Check if a SQLite database is encrypted\n     * @param database\n     * @returns Promise<Result>\n     * @since 3.2.0\n     */\n    isDatabaseEncrypted(database: string): Promise<Result>;\n    /**\n     * Check encryption value in capacitor.config\n     * @returns Promise<Result>\n     * @since 3.2.0\n     */\n    isInConfigEncryption(): Promise<Result>;\n    /**\n     * Check encryption value in capacitor.config\n     * @returns Promise<Result>\n     * @since 3.2.0\n     */\n    isInConfigBiometricAuth(): Promise<Result>;\n\n    /**\n     * Get a Non-Conformed database path\n     * @param databasePath\n     * @param version\n     * @returns Promise<capNCDatabasePathResult>\n     * @since 2.1.4\n     */\n    getNCDatabasePath(folderPath: string, database: string): Promise<capNCDatabasePathResult>;\n    /**\n     * Create a Non-Conformed database connection\n     * @param databasePath\n     * @param version\n     * @returns Promise<SQLiteDBConnection>\n     * @since 2.1.4\n     */\n    createNCConnection(databasePath: string, version?: number): Promise<SQLiteDBConnection>;\n    /**\n     * Retrieve a Non-Conformed database connection\n     * @param databasePath\n     * @returns Promise<SQLiteDBConnection>\n     * @since 2.1.4\n     */\n    retrieveNCConnection(databasePath: string): Promise<SQLiteDBConnection>;\n    /**\n     * Close a Non-Conformed database connection\n     * @param databasePath\n     * @returns Promise<void>\n     * @since 2.1.4\n     */\n    closeNCConnection(databasePath: string): Promise<void>;\n    /**\n     * Check if Non-Conformed database connection exists\n     * @param databasePath\n     * @returns Promise<Result>\n     * @since 2.1.4\n     */\n    isNCConnection(databasePath: string): Promise<Result>;\n    /**\n     * Check if Non-Conformed database exists\n     * @param databasePath\n     * @returns Promise<Result>\n     * @since 2.1.4\n     */\n    isNCDatabase(databasePath: string): Promise<Result>;\n    /**\n     * Get the database list\n     * @returns Promise<capSQLiteValues>\n     * @since 1.0.1 refactor\n     */\n    getDatabaseList(): Promise<capSQLiteValues>;\n    /**\n     * Get Migratable database List\n     * @param folderPath\n     * @returns Promise<capSQLiteValues>\n     * @since 2.1.1\n     */\n    getMigratableDbList(folderPath?: string): Promise<capSQLiteValues>\n     /**\n     * Add SQLIte Suffix to existing databases\n     * @param folderPath\n     * @param dbNameList since 2.1.1\n     * @returns Promise<void>\n     * @since 2.0.0\n     */\n    addSQLiteSuffix(folderPath?: string, dbNameList?: string[]): Promise<void>\n    /**\n     * Delete Old Cordova databases\n     * @param folderPath\n     * @param dbNameList since 2.1.1\n     * @returns Promise<void>\n     * @since 2.0.0\n     */\n    deleteOldDatabases(folderPath?: string, dbNameList?: string[]): Promise<void>;\n    /**\n     * Import a database From a JSON\n     * @param jsonstring string\n     * @returns Promise<capSQLiteChanges>\n     * @since 1.0.0 refactor\n     */\n    importFromJson(jsonstring: string): Promise<capSQLiteChanges>;\n    /**\n     * Check the validity of a JSON Object\n     * @param jsonstring string\n     * @returns Promise<Result>\n     * @since 1.0.0 refactor\n     */\n    isJsonValid(jsonstring: string): Promise<Result>;\n\n    /**\n     * Copy databases from assets to application database folder\n     * @param overwrite boolean\n     * @returns Promise<void>\n     * @since 2.0.0\n     */\n    copyFromAssets(overwrite?: boolean): Promise<void>;\n    /**\n     * Get databases from HTTP request to application database folder\n     * @param url string\n     * @param overwrite boolean\n     * @returns Promise<void>\n     * @since 3.0.2\n     */\n     getFromHTTPRequest(url: string, overwrite?: boolean): Promise<void>;\n     /**\n     * Check the consistency between Js Connections\n     * and Native Connections\n     * if inconsistency all connections are removed\n     * @returns Promise<Result>\n     * @since 2.0.1\n     */\n    checkConnectionsConsistency(): Promise<Result>;\n    /**\n     * Check if secure secret has been stored\n     * @returns Promise<Result>\n     * @since 2.0.2\n     */\n    isSecretStored(): Promise<Result>; \n    /**\n     * Set an encrypted secret to secure storage\n     * To run only once\n     * Will migrate from GlobalSQLite secret when required\n     * @param passphrase \n     * @returns Promise<void>\n     * @since 2.0.2\n     */\n    setEncryptionSecret(passphrase: string): Promise<void>;   \n    /**\n     * Change encrypted secret from secure storage\n     * Not to use to migrate from GlobalSQLite secret (run setEncryptionSecret)\n     * @param passphrase \n     * @param oldpassphrase \n     * @returns Promise<void>\n     * @since 2.0.2\n     */\n    changeEncryptionSecret(passphrase: string, oldpassphrase: string): Promise<void>; \n    /**\n     * Clear the encrypted secret from secure storage\n     * @returns Promise<void>\n     * @since 3.0.0\n     */ \n    clearEncryptionSecret(): Promise<void>;   \n    /**\n     * Check encryption passphrase\n     *\n     * @param passphrase \n     * @return Promise<Result>\n     * @since 3.2.0\n     */\n    checkEncryptionSecret(passphrase: string): Promise<Result>;\n    /**\n     * Moves databases to the location the plugin can read them, and adds sqlite suffix\n     * This resembles calling addSQLiteSuffix and deleteOldDatabases, but it is more performant as it doesn't copy but moves the files\n     * @param folderPath the origin from where to move the databases\n     * @param dbNameList the names of the databases to move, check out the getMigratableDbList to get a list, an empty list will result in copying all the databases with '.db' extension.\n     */\n    moveDatabasesAndAddSuffix(folderPath?: string, dbNameList?: string[],): Promise<void>;\n\n}\n\nexport interface MySet {\n    statement?: string;\n    values?: any[];\n}\n\nexport interface VersionUpgrade {\n    toVersion: number;\n    statements: string[];\n}\n\nexport interface Result {\n    result?: boolean;\n    message?: string\n}\n\n\n/**\n * useSQLite Hook\n */\nexport const useSQLite = (onProgress? : SQLiteProps): SQLiteHook  => {\n    const platform = Capacitor.getPlatform();\n    const sqlitePlugin: any = CapacitorSQLite;\n    const mSQLite = useMemo(() => {\n        return new SQLiteConnection(sqlitePlugin);\n    },[sqlitePlugin])\n    const listenerHasChangedRef = useRef(false);\n\n    useEffect(() => {\n        // init Listeners\n        let importListener: any = null;\n        let exportListener: any = null;    \n        if(platform != \"electron\") {   \n            if( onProgress && listenerHasChangedRef.current === false) { \n                console.log(`in onProgress add listeners `)\n                listenerHasChangedRef.current = true;\n                if(onProgress.onProgressImport && sqlitePlugin) importListener =\n                    sqlitePlugin.addListener('sqliteImportProgressEvent',\n                    (e: any) => {\n                        if(typeof onProgress.onProgressImport !== 'undefined')\n                        onProgress.onProgressImport(e.progress);\n                    });\n                if(onProgress.onProgressExport && sqlitePlugin) exportListener =\n                    sqlitePlugin.addListener('sqliteExportProgressEvent',\n                    (e: any) => {\n                        if(typeof onProgress.onProgressExport !== 'undefined')\n                        onProgress.onProgressExport(e.progress);\n                    });\n                }\n            }\n        return () => {\n            if(platform != \"electron\") {  \n                console.log(`in return remove listeners `)\n                if( listenerHasChangedRef.current === true) {\n                    sqlitePlugin.removeAllListeners();\n                }\n            }\n        }\n    }, []);\n\n    const availableFeaturesN = {\n        useSQLite: isFeatureAvailable('CapacitorSQLite', 'useSQLite')\n    }\n\n    /**\n     * Initialize the Web Store\n     */\n    const initWebStore = useCallback(async (): Promise<void> => {\n        if(platform != \"web\") { \n            return Promise.reject(`Not implemented on platform ${platform}`);\n        }\n\n        try {\n            await mSQLite.initWebStore();\n            return Promise.resolve();\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    /**\n     * Save the Database to store\n     * @param dbName string\n     */\n    const saveToStore = useCallback(async (dbName: string): Promise<void> => {\n        if(platform != \"web\") { \n            return Promise.reject(`Not implemented on platform ${platform}`);\n        }\n        if(dbName.length > 0) {\n            try {\n                await mSQLite.saveToStore(dbName);\n                return Promise.resolve();\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        } else {\n            return Promise.reject('Must provide a database name');\n        }\n    }, [mSQLite]);\n    \n\n    const echo = useCallback(async (value: string): Promise<any> => {\n        if(value) {\n            const r = await mSQLite.echo(value);\n            if(r) {\n                return r;\n            } else {\n                return {value: null};\n            }\n        } else {\n            return {value: null};\n        }\n    }, [mSQLite]);\n\n    const getPlatform = useCallback(async (): Promise<any> => {\n            return {platform: platform};\n    }, [platform]);\n    /**\n     *  Get CapacitorSQLite plugin\n     */\n     const getCapacitorSQLite = async (): Promise<any> => {\n        return {plugin: sqlitePlugin};\n    }\n    /**\n     * Create a Connection to Database\n     * @param dbName string\n     * @param encrypted boolean optional \n     * @param mode string optional\n     * @param version number optional\n     * @param readonly boolean optional since 3.0.1\n     */  \n    const createConnection = useCallback(async (dbName: string,\n        encrypted?: boolean,\n        mode?: string,\n        version?: number,\n        readonly?: boolean\n        )\n                : Promise<SQLiteDBConnection> => {\n        if (dbName == null || dbName.length === 0) {\n            return Promise.reject(new Error('Must provide a database name'));\n        } \n        const mDatabase: string = dbName;\n        const mVersion: number = version ? version : 1;\n        const mEncrypted: boolean = encrypted ? encrypted : false;\n        const mMode: string = mode ? mode : \"no-encryption\";\n        const mReadonly: boolean = readonly ? readonly : false;\n        try {\n            const r = await mSQLite.createConnection(\n                mDatabase, mEncrypted, mMode, mVersion, mReadonly);\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject(\"No returned connection\");\n            } \n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    /**\n     * Close the Connection to the Database\n     * @param dbName string\n     * @param readonly boolean optional since 3.0.1\n     */\n    const closeConnection = useCallback(async (dbName: string,\n                                               readonly?: boolean): Promise<void> => {\n        const mReadonly: boolean = readonly ? readonly : false;\n        if(dbName.length > 0) {\n            try {\n                await mSQLite.closeConnection(dbName, mReadonly);\n                return Promise.resolve();\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        } else {\n            return Promise.reject('Must provide a database name');\n        }\n    }, [mSQLite]);\n    /**\n     * Check if database connection exists\n     * @param database\n     * @param readonly boolean optional since 3.0.1\n     */\n     const isConnection = useCallback(async (dbName: string,\n                                             readonly?: boolean): Promise<Result> => {\n        const mReadonly: boolean = readonly ? readonly : false;\n        if(dbName.length > 0) {\n            try {\n                const r = await mSQLite.isConnection(dbName, mReadonly);\n                if(r) {\n                        return Promise.resolve(r);\n                } else {\n                    return Promise.reject(\"No returned isConnection\");\n                }\n            } catch (err) {\n                return Promise.reject(err);\n            } \n        } else {\n            return Promise.reject('Must provide a database name');\n        }\n\n    }, [mSQLite]);\n    /**\n     * Check if database exists\n     * @param database\n     */\n    const isDatabase = useCallback(async (dbName: string): Promise<Result> => {\n        if(dbName.length > 0) {\n            try {\n\n                const r = await mSQLite.isDatabase(dbName);\n                if(r) {\n                    return Promise.resolve(r);\n                } else {\n                    return Promise.reject(\"Error in isDatabase\");\n                }\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        } else {\n            return Promise.reject('Must provide a database name');\n        }\n\n    }, [mSQLite]);\n    /**\n     * Check if a SQLite database is encrypted\n     * @param database\n     * @returns Promise<Result>\n     * @since 3.2.0\n     */\n    const isDatabaseEncrypted = useCallback(async (dbName: string): Promise<Result> => {\n        if(dbName.length > 0) {\n            try {\n\n                const r = await mSQLite.isDatabaseEncrypted(dbName);\n                if(r) {\n                    return Promise.resolve(r);\n                } else {\n                    return Promise.reject(\"Error in isDatabaseEncrypted\");\n                }\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        } else {\n            return Promise.reject('Must provide a database name');\n        }\n    }, [mSQLite]);\n    /**\n     * Check encryption value in capacitor.config\n     * @returns Promise<Result>\n     * @since 3.2.0\n     */\n    const isInConfigEncryption = useCallback(async (): Promise<Result> => {\n        try {\n\n            const r = await mSQLite.isInConfigEncryption();\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject(\"Error in isInConfigEncryption\");\n            }\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    /**\n     * Check encryption value in capacitor.config\n     * @returns Promise<Result>\n     * @since 3.2.0\n     */\n    const isInConfigBiometricAuth = useCallback(async (): Promise<Result> => {\n        try {\n\n            const r = await mSQLite.isInConfigBiometricAuth();\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject(\"Error in isInConfigBiometricAuth\");\n            }\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    \n    /**\n     * Get the database list\n     * @returns Promise<capSQLiteValues>\n     * @since 1.0.1 refactor\n     */\n    const getDatabaseList = useCallback(async (): Promise<capSQLiteValues> => {\n        try {\n            const r = await mSQLite.getDatabaseList();\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject(\"Error in getDatabaseList\");\n            }\n        } catch (err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Get the migratable database list\n     * @param folderPath\n     * \n     */\n     const getMigratableDbList = useCallback(async (folderPath?: string): Promise<capSQLiteValues> => {\n        const path: string = folderPath ? folderPath : \"default\"\n        try {\n            const r = await mSQLite.getMigratableDbList(path);\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject(\"Error in getMigratableDbList\");\n            }\n        } catch(err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Add SQLIte Suffix to existing databases\n     * @param folderPath\n     * @param dbNameList\n     */\n    const addSQLiteSuffix = useCallback(async (folderPath?: string, dbNameList?: string[]): Promise<void> => {\n        const path: string = folderPath ? folderPath : \"default\"\n        const dbList: string[] = dbNameList ? dbNameList : []\n        try {\n            await mSQLite.addSQLiteSuffix(path, dbList);\n            return Promise.resolve();\n        } catch(err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Delete Old Cordova databases\n     * @param folderPath\n     * @param dbNameList\n     */\n    const deleteOldDatabases = useCallback(async (folderPath?: string, dbNameList?: string[]): Promise<void> => {\n        const path: string = folderPath ? folderPath : \"default\"\n        const dbList: string[] = dbNameList ? dbNameList : []\n        try {\n            await mSQLite.deleteOldDatabases(path, dbList);\n            return Promise.resolve();\n        } catch(err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n\n    /**\n     * Retrieve a Connection to the Database\n     * @param dbName string\n     * @param readonly boolean optional since 3.0.1\n     */\n    const retrieveConnection = useCallback(async (dbName: string,\n                                                  readonly?:boolean): Promise<SQLiteDBConnection> => {\n        const mReadonly: boolean = readonly ? readonly : false;\n        if(dbName.length > 0) {\n            try {\n                const r = await mSQLite.retrieveConnection(dbName, mReadonly);\n                if(r) {\n                    return Promise.resolve(r);\n                } else {\n                    return Promise.reject(\"No returned connection\");\n                }\n            } catch (err) {\n                return Promise.reject(err);\n            }        \n        } else {\n            return Promise.reject('Must provide a database name');\n        }        \n    }, [mSQLite]);\n    /**\n     * Retrieve all Connections to Databases\n     * \n     */\n    const retrieveAllConnections = useCallback(async (): Promise<Map<string, SQLiteDBConnection>> => {\n        try {\n            const r = await mSQLite.retrieveAllConnections();\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject(\"No returned connection\");\n            }\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    /**\n     * Close All Connections to Databases\n     * @param dbName string\n     */\n    const closeAllConnections = useCallback(async (): Promise<void> => {\n        try {\n            await mSQLite.closeAllConnections();\n            return Promise.resolve();\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    /**\n     * Import from Json \n     * @param jsonstring string\n     */\n    const importFromJson = useCallback(async (jsonstring: string): Promise<capSQLiteChanges> => {\n\n        try {\n            const r = await mSQLite.importFromJson(jsonstring);\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject('Error in importFromJson');\n            } \n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    /**\n     * Is Json Valid\n     * @param jsonstring string\n     */\n    const isJsonValid = useCallback(async (jsonstring: string): Promise<Result> => {\n\n        try {\n            const r = await mSQLite.isJsonValid(jsonstring);\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject('Error Json Object not valid');\n            } \n        } catch (err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Add the upgrade Statement for database version upgrading\n     * @param dbName string \n     * @param upgrade VersionUpgrade\n     */\n    const addUpgradeStatement = useCallback(async (dbName:string,\n                upgrade: VersionUpgrade): Promise<void> => {\n        if(upgrade === null) {\n            return Promise.reject(new Error(\"Must provide an upgrade statement\"));\n        }\n        if(upgrade.toVersion === null\n            || upgrade.statements === null) {\n                let msg = \"Must provide an upgrade statement with \";\n                msg += \"toVersion & statements\"\n                return Promise.reject(msg);\n            }\n\n        if(dbName.length > 0) {\n            try {\n                await mSQLite\n                .addUpgradeStatement(dbName, upgrade.toVersion,\n                                     upgrade.statements);\n                return Promise.resolve();\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        } else {\n            return Promise.reject('Must provide a database name');\n        }\n    }, [mSQLite]);\n    /**\n     * Copy databases from assets to application database folder\n     */\n    const copyFromAssets = useCallback(async (overwrite?: boolean) : Promise<void> => {\n        const mOverwrite = overwrite!= null ? overwrite : true;\n        try {\n            await mSQLite.copyFromAssets(overwrite);\n            return Promise.resolve();\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    /**\n     * Get databases from HTTP request to application database folder\n     */\n     const getFromHTTPRequest = useCallback(async (url: string, overwrite?: boolean) : Promise<void> => {\n        const mOverwrite = overwrite!= null ? overwrite : true;\n        try {\n            await mSQLite.getFromHTTPRequest(url, overwrite);\n            return Promise.resolve();\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    /**\n     * Check the consistency between Js Connections\n     * and Native Connections\n     * if inconsistency all connections are removed\n     */\n    const checkConnectionsConsistency = useCallback(async () : Promise<Result> => {\n        try {\n            const r = await mSQLite.checkConnectionsConsistency();\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject('Error Json Object not valid');\n            } \n        } catch (err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Check if secure secret has been stored\n     * @returns Promise<Result>\n     * @since 2.0.2\n     */\n    const isSecretStored = useCallback(async (): Promise<Result> => {\n        try {\n            const r = await mSQLite.isSecretStored();\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject('Error in isSecretStored');\n            } \n        } catch (err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Set an encrypted secret to secure storage\n     * To run only once\n     * Will migrate from GlobalSQLite secret when required\n     * @param passphrase \n     * @returns Promise<void>\n     * @since 2.0.2\n    */\n    const setEncryptionSecret = useCallback(async (passphrase: string): Promise<void> => {\n        if (passphrase == null || passphrase.length === 0) {\n            return Promise.reject(new Error('Must provide a passphrase'));\n        } \n        try {\n            await mSQLite.setEncryptionSecret(passphrase);\n            return Promise.resolve();\n        } catch(err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Change encrypted secret from secure storage\n     * Not to use to migrate from GlobalSQLite secret (run setEncryptionSecret)\n     * @param passphrase \n     * @param oldpassphrase \n     * @returns Promise<void>\n     * @since 2.0.2\n     */\n    const changeEncryptionSecret = useCallback(async (passphrase: string,\n        oldpassphrase: string): Promise<void> => {\n        if (passphrase == null || passphrase.length === 0) {\n            return Promise.reject(new Error('Must provide a passphrase'));\n        } \n        if (oldpassphrase == null || oldpassphrase.length === 0) {\n            return Promise.reject(new Error('Must provide the old passphrase'));\n        } \n        try {\n            await mSQLite.changeEncryptionSecret(passphrase, oldpassphrase);\n            return Promise.resolve();\n        } catch(err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Clear the encrypted secret from secure storage\n     * @returns Promise<void>\n     * @since 3.0.0\n     */ \n     const clearEncryptionSecret = useCallback(async (): Promise<void> => {\n        try {\n            await mSQLite.clearEncryptionSecret();\n            return Promise.resolve();\n        } catch(err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Check Encryption Secret\n     * \n     * @param passphrase \n     * @returns Promise<Result>\n     * @since 3.2.0\n     */\n    const checkEncryptionSecret = useCallback( async(passphrase: string): Promise<Result> => {\n        try {\n            const r = await mSQLite.checkEncryptionSecret(passphrase);\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject('Error in checkEncryptionSecret');\n            } \n        } catch (err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n    /**\n     * Get a Non-Conformed database path\n     * @param databasePath\n     * @param version\n     * @returns Promise<capNCDatabasePathResult>\n     * @since 2.1.4\n     */\n    const getNCDatabasePath = useCallback(async (folderPath: string, database: string): Promise<capNCDatabasePathResult> => {\n        if (folderPath == null || folderPath.length === 0) {\n            return Promise.reject(new Error('Must provide a folder path'));\n        } \n        if (database == null || database.length === 0) {\n            return Promise.reject(new Error('Must provide a database name'));\n        } \n        const mFolderPath: string = folderPath;\n        const mDatabase: string = database;\n        try {\n            const r = await mSQLite.getNCDatabasePath(\n                mFolderPath, mDatabase);\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject(\"No returned database path\");\n            } \n        } catch (err) {\n            return Promise.reject(err);\n        }\n\n    }, [mSQLite]);\n     /**\n     * Create a Non-Conformed Database Connection \n     * @param databasePath string\n     * @param version number optional\n     * @since 2.1.4\n     */  \n     const createNCConnection = useCallback(async (databasePath: string, version?: number)\n                                : Promise<SQLiteDBConnection> => {\n        if (databasePath == null || databasePath.length === 0) {\n            return Promise.reject(new Error('Must provide a database path'));\n        } \n        const mDatabasePath: string = databasePath;\n        const mVersion: number = version ? version : 1;\n        try {\n            const r = await mSQLite.createNCConnection(\n                mDatabasePath, mVersion);\n            if(r) {\n                return Promise.resolve(r);\n            } else {\n                return Promise.reject(\"No returned NC connection\");\n            } \n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }, [mSQLite]);\n    /**\n     * Retrieve a Non-Conformed Database Connection \n     * @param databasePath string\n     * @since 2.1.4\n     */\n     const retrieveNCConnection = useCallback(async (databasePath: string): Promise<SQLiteDBConnection> => {\n        if(databasePath.length > 0) {\n            try {\n                const r = await mSQLite.retrieveNCConnection(databasePath);\n                if(r) {\n                    return Promise.resolve(r);\n                } else {\n                    return Promise.reject(\"No returned NC connection\");\n                }\n            } catch (err) {\n                return Promise.reject(err);\n            }        \n        } else {\n            return Promise.reject('Must provide a database path');\n        }        \n    }, [mSQLite]);\n\n    /**\n     * Close a Non-Conformed Database Connection \n     * @param databasePath string\n     * @since 2.1.4\n     */\n    const closeNCConnection = useCallback(async (databasePath: string): Promise<void> => {\n        if(databasePath.length > 0) {\n            try {\n                await mSQLite.closeNCConnection(databasePath);\n                return Promise.resolve();\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        } else {\n            return Promise.reject('Must provide a database path');\n        }\n    }, [mSQLite]);\n    /**\n     * Check if a Non-Conformed Database Connection  exists\n     * @param databasePath\n     * @since 2.1.4\n     */\n     const isNCConnection = useCallback(async (databasePath: string): Promise<Result> => {\n        if(databasePath.length > 0) {\n            try {\n                const r = await mSQLite.isNCConnection(databasePath);\n                if(r) {\n                        return Promise.resolve(r);\n                } else {\n                    return Promise.reject(\"No returned  NC Connection\");\n                }\n            } catch (err) {\n                return Promise.reject(err);\n            } \n        } else {\n            return Promise.reject('Must provide a database path');\n        }\n\n    }, [mSQLite]);\n    /**\n     * Check if database exists\n     * @param databasePath\n     * @since 2.1.4\n     */\n    const isNCDatabase = useCallback(async (databasePath: string): Promise<Result> => {\n        if(databasePath.length > 0) {\n            try {\n\n                const r = await mSQLite.isNCDatabase(databasePath);\n                if(r) {\n                    return Promise.resolve(r);\n                } else {\n                    return Promise.reject(\"No returned  NC Connection\");\n                }\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        } else {\n            return Promise.reject('Must provide a database path');\n        }\n\n    }, [mSQLite]);\n    /**\n     * Moves databases to the location the plugin can read them, and adds sqlite suffix\n     * This resembles calling addSQLiteSuffix and deleteOldDatabases, but it is more performant as it doesn't copy but moves the files\n     * @param folderPath the origin from where to move the databases\n     * @param dbNameList the names of the databases to move, check out the getMigratableDbList to get a list, an empty list will result in copying all the databases with '.db' extension.\n     */\n    const moveDatabasesAndAddSuffix = useCallback(async (folderPath?: string, dbNameList?: string[],): Promise<void> => {\n        const path: string = folderPath ? folderPath : 'default';\n        const dbList: string[] = dbNameList ? dbNameList : [];\n        try {\n            await mSQLite.moveDatabasesAndAddSuffix(path, dbList);\n            return Promise.resolve();\n        } catch(err) {\n            return Promise.reject(err);\n        }\n    \n    }, [mSQLite]);\n\n    if (!availableFeaturesN.useSQLite) {\n        return {\n            initWebStore: featureNotAvailableError,\n            saveToStore: featureNotAvailableError,\n            echo: featureNotAvailableError,\n            getPlatform: featureNotAvailableError,\n            getCapacitorSQLite: featureNotAvailableError,\n            createConnection: featureNotAvailableError,\n            closeConnection: featureNotAvailableError,\n            retrieveConnection: featureNotAvailableError,\n            retrieveAllConnections: featureNotAvailableError,\n            closeAllConnections: featureNotAvailableError,\n            addUpgradeStatement: featureNotAvailableError,\n            importFromJson: featureNotAvailableError,\n            isJsonValid: featureNotAvailableError,\n            copyFromAssets: featureNotAvailableError,\n            getFromHTTPRequest: featureNotAvailableError,\n            isConnection: featureNotAvailableError,\n            isDatabase: featureNotAvailableError,\n            getNCDatabasePath: featureNotAvailableError,\n            createNCConnection: featureNotAvailableError,\n            closeNCConnection: featureNotAvailableError,\n            retrieveNCConnection: featureNotAvailableError,\n            isNCConnection: featureNotAvailableError,\n            isNCDatabase: featureNotAvailableError,\n            getDatabaseList: featureNotAvailableError,\n            getMigratableDbList: featureNotAvailableError,\n            addSQLiteSuffix: featureNotAvailableError,\n            deleteOldDatabases: featureNotAvailableError,\n            checkConnectionsConsistency: featureNotAvailableError,\n            isSecretStored: featureNotAvailableError,\n            setEncryptionSecret: featureNotAvailableError,\n            changeEncryptionSecret: featureNotAvailableError,\n            clearEncryptionSecret: featureNotAvailableError,\n            checkEncryptionSecret: featureNotAvailableError,\n            moveDatabasesAndAddSuffix: featureNotAvailableError,\n            isInConfigEncryption: featureNotAvailableError,\n            isInConfigBiometricAuth: featureNotAvailableError,\n            isDatabaseEncrypted: featureNotAvailableError,            \n            ...notAvailable\n        };\n    } else {\n        return {echo, getPlatform, getCapacitorSQLite, createConnection, closeConnection,\n            retrieveConnection, retrieveAllConnections, closeAllConnections,\n            addUpgradeStatement, importFromJson, isJsonValid, copyFromAssets, getFromHTTPRequest,\n            isConnection, isDatabase, getDatabaseList, getMigratableDbList, addSQLiteSuffix,\n            deleteOldDatabases, checkConnectionsConsistency, \n            isSecretStored, setEncryptionSecret, changeEncryptionSecret,\n            clearEncryptionSecret, checkEncryptionSecret, moveDatabasesAndAddSuffix,\n            initWebStore, saveToStore, getNCDatabasePath, createNCConnection,\n            closeNCConnection, retrieveNCConnection, isNCConnection, isNCDatabase,\n            isInConfigEncryption, isInConfigBiometricAuth, isDatabaseEncrypted, isAvailable: true};\n    }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}